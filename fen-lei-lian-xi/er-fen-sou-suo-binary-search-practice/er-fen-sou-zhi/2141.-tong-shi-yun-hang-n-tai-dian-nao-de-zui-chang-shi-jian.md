# 2141. 同时运行 N 台电脑的最长时间

你有 `n` 台电脑。给你整数 `n` 和一个下标从 **0** 开始的整数数组 `batteries` ，其中第 `i` 个电池可以让一台电脑 **运行** `batteries[i]` 分钟。你想使用这些电池让 **全部** `n` 台电脑 **同时** 运行。

一开始，你可以给每台电脑连接 **至多一个电池** 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 **任意次** 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。

注意，你不能给电池充电。

请你返回你可以让 `n` 台电脑同时运行的 **最长** 分钟数。

&#x20;

**示例 1：**

![](https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png)

```
输入：n = 2, batteries = [3,3,3]
输出：4
解释：
一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。
2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。
在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。
在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。
我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2022/01/06/example2.png)

```
输入：n = 2, batteries = [1,1,1,1]
输出：2
解释：
一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。
一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。
1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。
我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。
```

&#x20;

**提示：**

* `1 <= n <= batteries.length <= 105`
* `1 <= batteries[i] <= 109`

设本题电脑同时运行时间为P，这也是我们不断二分得到的结果。\
设一共有K台电脑，我们的目的是在P的时间内不断运转他们。\
因此，我们的目的其实是看电池的状态能不能填满P\*K的矩形。

![image.png](https://pic.leetcode-cn.com/1642313940-engFNq-image.png)\
上部分代表了一种电池的合法分布情况。\
很明显，当Batteries0(黄色)的数量超过了P，我们其实只需要P即可，剩下的都只能抛弃。\
当Batteries1(橘色)的数量小于P，我们需要把当前电池全部用完。同时提前借用别的电池来填充该列。

然而，下面也有NG的情况。我们把橘色电池容量-1，红色的+1，再来看看我们构造的矩形。因为一行不能存在2个同样的颜色（即不能存在一个电池给2个电脑续航的情况)，所以红色的电池会浪费掉一个(对应了代码里的min(p, 红色电池容量))，最终导致矩形的构造失败。\
总结一下可以用这个心态来构造矩形：小于P的时候，贪心地利用多个电池，但是同时不能在一行里有相同的颜色。

```cpp
auto check = [&](i64 mid) {
            i64 sum = 0;
            for(int x : batteries) sum += min(mid, (i64)x);
            return sum >= n * mid;
        };
```

全部代码:

```cpp
typedef long long i64;
class Solution {
public:
    long long maxRunTime(int n, vector<int>& batteries) {
        auto check = [&](i64 mid) {
            i64 sum = 0;
            for(int x : batteries) sum += min(mid, (i64)x);
            return sum >= n * mid;
        };
        i64 l = 0, r = 1e16/n;
        while (l < r) {
            i64 mid = l + r + 1>> 1;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
```
