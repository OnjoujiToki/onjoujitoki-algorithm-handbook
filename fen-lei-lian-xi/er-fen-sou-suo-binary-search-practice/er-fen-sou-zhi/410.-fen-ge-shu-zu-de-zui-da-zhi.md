# 410. 分割数组的最大值

给定一个非负整数数组 `nums` 和一个整数 `m` ，你需要将这个数组分成 `m` 个非空的连续子数组。

设计一个算法使得这 `m` 个子数组各自和的最大值最小。

**示例 1：**

```
输入：nums = [7,2,5,10,8], m = 2
输出：18
解释：
一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```

**示例 2：**

```
输入：nums = [1,2,3,4,5], m = 2
输出：9
```

**示例 3：**

```
输入：nums = [1,4,4], m = 3
输出：4
```

**提示：**

* `1 <= nums.length <= 1000`
* `0 <= nums[i] <= 106`
* `1 <= m <= min(50, nums.length)`

**方法一：二分答案**

能用二分的前提条件是有二段性。本体保证了所有的数字全部都是正数。因此可以用二分。

我们需要判断持否存在一个划分方式，使得总和不超过mid的情况下，能够分成m段。

那么我们如何求证最大值不超过mid呢。考虑到非负性，用贪心即可，能取多少即可。

贪心的证明比较简单，因为数的非负性，以下的2个情况都很好判断。

1. 贪心解 >= 最优解，比较明显。
2. 贪心解 <= 最优解。最优解的当前段总和如果大于贪心出来的子数组的总和，那么必然保证最优解的下一段会“赔偿”，不会影响结果。

因此在我们二分到mid的时候，check函数只需要贪心地遍历数组即可。

```cpp
class Solution {
public:
    int splitArray(vector<int>& nums, int m) {
        int l = 0, r = INT_MAX;
        auto check = [&](int mid) {
            int sum = 0, cur = 0;
            for(auto& x : nums) {
                if (x > mid) return false;
                if (sum + x > mid) {
                    sum = x;
                    cur++;
                } else sum += x;
            }
            if (sum) cur++;
            return cur <= m;
        };
        while(l < r) {
            int mid = (long long)l + r >> 1;
            if (check(mid)) {
                r = mid;
            } else l = mid + 1;
        }
        return l;
    }
};
```
