# 440. 字典序的第K小数字

给定整数 `n` 和 `k`，找到 `1` 到 `n` 中字典序第 `k` 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

**示例 :**

```
输入:n: 13   k: 2​
输出:10
​解释:字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

数位统计问题，可以抽象成一个十叉树或许比较好理解？但是没什么必要。

为了统计数量，我们可以一位一位来看答案的前缀，我们的初始前缀是1。

首先要解决的是如何获取该前缀下所有子节点的个数 计算以数字 prefix 开头且不超过最大数字 n 的数字个数

用下一个前缀的起点减去当前前缀的起点，即为当前前缀的总和。因此我们可以这样划分的左闭右开的区间\[prefix, prefix+1)，我们的目标就是求出里面所有的数字。 考虑到这个区间的终点可能已经超过n了，因此我们取最小值可以排除掉超过n的情况。即`min(n + 1, next) - cur`

在主函数里，我们需要一个计数器`cur`，当计数器小于k的时候一直进行循环。如果计算当前前缀的所有数字加起来都还没有达到k，那我们可以直接对计数器加上当前前缀的合法数量，然后再跟新prefix。如果还已经超过了我们需要的数字，也就是说kth数字肯定是prefix开头。这时候prefix\*10，更新我们在字典序里位数，可以理解为将数位右移一位。然后再度缩小范围，计算当前prefix的cnt，直到`else if (cur + cnt <= k)`，并得到我们需要的k。返回prefix即可。



```cpp
typedef long long i64;
i64 count(i64 cur, i64 n) {
    // 区间起点cur，区间的终点是cur + 1
    i64 next = cur + 1; // 下一个前缀
    i64 cnt = 0;
    while (cur <= n) {
        cnt += min(n + 1, next) - cur; // 下一个前缀的起点减去当前前缀的起点
        // 考虑到这个区间的终点可能已经超过n了，因此我们取最小值可以排除掉超过n的情况
        cur *= 10;
        next *= 10; 
        // 更新cur和next直到不合法
    }
    return cnt;
}

int findKthNumber(int n, int k) {
    i64 prefix = 1;
    i64 cur = 1;
    while (cur < k) {
        i64 cnt =  count(prefix, n);
        if (cur + cnt  > k) {
            // 已经超过了我们需要的数字，kth数字肯定是prefix开头
            prefix *= 10;
            cur++;
        } else { // 也就是 else if (cur + cnt <= k) 
            // 需要更新前缀的情况
            prefix++;
            cur += cnt;
        }
    }
    return prefix;
}
```

\
