# 664. 奇怪的打印机

有台奇怪的打印机有以下两个特殊要求：

* 打印机每次只能打印由 **同一个字符** 组成的序列。
* 每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。

给你一个字符串 `s` ，你的任务是计算这个打印机打印它需要的最少打印次数。

**示例 1：**

```
输入：s = "aaabbb"输出：2解释：首先打印 "aaa" 然后打印 "bbb"。
```

**示例 2：**

```
输入：s = "aba"输出：2解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。
```

**提示：**

* `1 <= s.length <= 100`
* `s` 由小写英文字母组成

[https://vjudge.net/problem/HDU-2476](https://vjudge.net/problem/HDU-2476)

题目原型是这个

单个字符串，可以recall一下区间dp的划分方法

**状态计算**

集合：所有将\[l,r]打印最终样子的方案次数

属性：最小值

**状态表示**

染到l, l + 1, l + 2, ... r。

r - l + 1种情况，分别求出来取min即可。

情况1 染（l only）

只染一个端点的话，染完之后满足了要求，再对剩下的进行讨论，这里要从后往前推，所以

把f\[l + 1, r] 染到最后就可以了，最后要 + 1，因为无论如何要进行至少一次的操作

情况2 染（l, k）

f\[l, k - 1] + f\[k + 1,r]

如果字符串中一段的字符相同，就可以归为这种情况。在本体情况是最小值。

这里不需要+1 因为之前可以顺带染着，但是要统计后端的染色方案数量。

为什么我们只需要确保s\[l] == s\[k]但是不用确保中间的字符，就可以了呢？因为在打印左端点到k的时候是一口气过来的，无论中间是什么。

```cpp
class Solution {
public:
    int strangePrinter(string s) {
        if (s.empty()) return 0;
        int n = s.size();
        vector<vector<int>> f(n + 1, vector<int>(n + 1));
        for (int len = 1; len <= n; len++) {
            for (int l = 0; l + len - 1 < n; l++) {
                int r = l + len - 1;
                f[l][r] = f[l + 1] [r] + 1;
                for (int k = l + 1; k <= r; k++) {
                    if (s[k] == s[l]) 
                        f[l][r] = min(f[l][r], f[l][k-1] + f[k + 1][r]);
                }
            }
        }
        return f[0][n-1];
    }
};
```

