# 583. 两个字符串的删除操作

给定两个单词 _word1_ 和 _word2_，找到使得 _word1_ 和 _word2_ 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

**示例：**

```
输入: "sea", "eat"输出: 2解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
```

**提示：**

1. 给定单词的长度不超过500。
2. 给定单词中的字符只含有小写字母。



简化版的编辑距离Edit distance。

但是也可以看成最长公共子序列问题。毕竟是找最长公共子序列然后删掉上下的部分.

首先初始化边界情况，空字符串和不空的字符串很自然想要如此初始化边界。

**状态表示**

集合：所有将S\_1\[1-i]变成S\_2\[1-j] 变成相同字符串的所有方案

属性：Min

**状态计算**

考虑第i和第j个字符。优先考虑i，j是否正确，分为4种情况

1. i j都对
2. i对j不对
3. j对i不队
4. 都不对

取min即可。

考虑情况1:

```
f[i][j] = f[i-1][j-1]
```

考虑情况2：

```
f[i][j] = f[i][j-1] + 1
```

考虑情况3：

```
f[i][j] = f[i-1][j] + 1
```

考虑情况4：

```
f[i][j] = f[i-1][j-1] + 2
```

我们可以从这4个情况总结成2个情况

情况1, 当前字符相等，我们可以直接从上一个情况的结论直接拖拽过来

```
if (word1[i-1] == word2[j-1]) f[i][j] = f[i-1][j-1];
```

情况2，当前字符不相等，就有3种情况要讨论

1.  删word 1

    ```
    f[i][j] = f[i-1][j] + 1
    ```
2.  删word 2

    ```
    f[i][j] = f[i][j-1] + 1
    ```
3.  删both

    ```
    f[i][j] = f[i-1][j-1] + 2
    ```

    取最小值即可。

\


```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector<vector<int>> f(m + 1, vector<int>(n + 1, 0));
        for (int i = 0; i <= m; i++) f[i][0] = i;
        for (int j = 0; j <= n; j++) f[0][j] = j;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i-1] == word2[j-1]) {
                    f[i][j] = f[i-1][j-1];
                } else {
                    f[i][j] = min({f[i-1][j] + 1, f[i][j-1] + 1, f[i-1][j-1] + 2});
                }
            }
        }
        return f[m][n];
    }
};  
```
